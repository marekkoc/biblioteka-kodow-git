Stwórzmy bazę danych SQL do przechowywania informacji o produktach. Użyjmy SQLAlchemy do obsługi bazy danych w Pythonie. Oto struktura:

```python
from sqlalchemy import create_engine, Column, Integer, String, Float, JSON, ForeignKey, Table
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, sessionmaker
from datetime import datetime

Base = declarative_base()

# Tabela łącząca dla relacji many-to-many między Product a Category
product_categories = Table('product_categories', Base.metadata,
    Column('product_id', Integer, ForeignKey('products.id')),
    Column('category_id', Integer, ForeignKey('categories.id'))
)

class Product(Base):
    __tablename__ = 'products'
    
    id = Column(Integer, primary_key=True)
    product_name = Column(String(255), nullable=False)
    manufacturer = Column(String(255))
    store_chain = Column(String(255))
    weight_volume = Column(String(50))
    ingredients = Column(JSON)  # Lista składników
    nutrition_facts = Column(JSON)  # Zagnieżdżony słownik wartości odżywczych
    vitamins_and_minerals = Column(JSON)
    allergens = Column(JSON)  # Lista alergenów
    barcode = Column(String(50), unique=True)
    expiry_date = Column(String(50))
    storage_conditions = Column(String(255))
    country_of_origin = Column(String(100))
    price = Column(Float)
    notes = Column(String(1000))
    created_at = Column(String(50), default=datetime.utcnow)
    updated_at = Column(String(50), default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relacje
    categories = relationship('Category', secondary=product_categories, back_populates='products')
    images = relationship('ProductImage', back_populates='product')

class Category(Base):
    __tablename__ = 'categories'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False, unique=True)
    parent_id = Column(Integer, ForeignKey('categories.id'))
    
    # Relacje
    products = relationship('Product', secondary=product_categories, back_populates='categories')
    children = relationship('Category')

class ProductImage(Base):
    __tablename__ = 'product_images'
    
    id = Column(Integer, primary_key=True)
    product_id = Column(Integer, ForeignKey('products.id'))
    image_path = Column(String(255))
    image_type = Column(String(50))  # np. 'front', 'back', 'nutrition', 'ingredients'
    
    # Relacja
    product = relationship('Product', back_populates='images')

# Klasa do zarządzania bazą danych
class DatabaseManager:
    def __init__(self, db_url='sqlite:///products.db'):
        self.engine = create_engine(db_url)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)

    def add_product(self, product_data):
        session = self.Session()
        try:
            # Tworzenie nowego produktu
            product = Product(**product_data)
            
            # Dodawanie kategorii
            if 'categories' in product_data:
                for category_name in product_data['categories']:
                    category = session.query(Category).filter_by(name=category_name).first()
                    if not category:
                        category = Category(name=category_name)
                        session.add(category)
                    product.categories.append(category)
            
            session.add(product)
            session.commit()
            return product.id
        except Exception as e:
            session.rollback()
            raise e
        finally:
            session.close()

    def get_product(self, product_id):
        session = self.Session()
        try:
            return session.query(Product).get(product_id)
        finally:
            session.close()

    def get_product_by_barcode(self, barcode):
        session = self.Session()
        try:
            return session.query(Product).filter_by(barcode=barcode).first()
        finally:
            session.close()

    def update_product(self, product_id, update_data):
        session = self.Session()
        try:
            product = session.query(Product).get(product_id)
            if product:
                for key, value in update_data.items():
                    if hasattr(product, key):
                        setattr(product, key, value)
                session.commit()
                return True
            return False
        except Exception as e:
            session.rollback()
            raise e
        finally:
            session.close()

    def delete_product(self, product_id):
        session = self.Session()
        try:
            product = session.query(Product).get(product_id)
            if product:
                session.delete(product)
                session.commit()
                return True
            return False
        except Exception as e:
            session.rollback()
            raise e
        finally:
            session.close()

# Przykład użycia:
if __name__ == '__main__':
    # Inicjalizacja bazy danych
    db_manager = DatabaseManager()
    
    # Przykładowe dane produktu
    product_data = {
        "product_name": "Yoghurt VANILLA",
        "manufacturer": "Q-Meieriene",
        "store_chain": "Kiwi",
        "weight_volume": "800g",
        "ingredients": ["Yogurt", "MILK", "vanilla", "sugar"],
        "nutrition_facts": {
            "per_100g": {
                "energy": "72 kcal",
                "protein": "4.4 g"
            }
        },
        "categories": ["Dairy", "Yogurt", "Vanilla Yogurt"],
        "barcode": "7048840005468"
    }
    
    # Dodanie produktu do bazy
    try:
        product_id = db_manager.add_product(product_data)
        print(f"Product added successfully with ID: {product_id}")
        
        # Pobranie produktu
        product = db_manager.get_product(product_id)
        print(f"Retrieved product: {product.product_name}")
        
    except Exception as e:
        print(f"Error: {str(e)}")
```

Ten kod:
1. Tworzy strukturę bazy danych z tabelami dla:
   - Produktów
   - Kategorii
   - Zdjęć produktów
   - Relacji między produktami a kategoriami

2. Zapewnia podstawowe operacje CRUD:
   - Dodawanie produktów
   - Pobieranie produktów (po ID lub kodzie kreskowym)
   - Aktualizacja produktów
   - Usuwanie produktów

3. Obsługuje:
   - Relacje many-to-many między produktami a kategoriami
   - Przechowywanie złożonych danych w formacie JSON
   - Śledzenie czasu utworzenia i aktualizacji
   - Obsługę błędów i transakcje

Możemy rozszerzyć tę bazę danych o:
1. Wyszukiwanie produktów
2. Filtrowanie po kategoriach
3. Statystyki
4. System wersjonowania zmian
5. Eksport/import danych

Co chciałbyś rozwinąć w pierwszej kolejności?
