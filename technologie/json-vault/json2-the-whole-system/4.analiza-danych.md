Stwórzmy moduł do analizy danych zebranych w naszej bazie. Będziemy używać pandas, matplotlib i seaborn do analizy i wizualizacji. Oto kod:

```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sqlalchemy import func
from collections import defaultdict
import numpy as np

class ProductAnalyzer:
    def __init__(self, db_manager):
        self.db_manager = db_manager
        self.session = db_manager.Session()

    def get_products_dataframe(self):
        """Konwertuje dane z bazy do pandas DataFrame"""
        products = self.session.query(Product).all()
        
        # Przygotowanie danych do DataFrame
        data = []
        for product in products:
            product_dict = {
                'id': product.id,
                'name': product.product_name,
                'manufacturer': product.manufacturer,
                'store': product.store_chain,
                'weight_volume': product.weight_volume,
                'price': product.price,
                'country': product.country_of_origin,
                'categories': [c.name for c in product.categories]
            }
            
            # Dodanie wartości odżywczych
            if product.nutrition_facts and 'per_100g' in product.nutrition_facts:
                nutrition = product.nutrition_facts['per_100g']
                if 'energy' in nutrition:
                    product_dict['calories'] = float(nutrition['energy'].split()[0])
                if 'protein' in nutrition:
                    product_dict['protein'] = float(nutrition['protein'].split()[0])
                if 'fats' in nutrition and 'total' in nutrition['fats']:
                    product_dict['total_fat'] = float(nutrition['fats']['total'].split()[0])
                if 'carbohydrates' in nutrition and 'total' in nutrition['carbohydrates']:
                    product_dict['total_carbs'] = float(nutrition['carbohydrates']['total'].split()[0])

            data.append(product_dict)
        
        return pd.DataFrame(data)

    def basic_statistics(self):
        """Generuje podstawowe statystyki dla produktów"""
        df = self.get_products_dataframe()
        
        stats = {
            'total_products': len(df),
            'unique_manufacturers': df['manufacturer'].nunique(),
            'unique_stores': df['store'].nunique(),
            'products_by_country': df['country'].value_counts().to_dict(),
            'average_price': df['price'].mean(),
            'price_range': (df['price'].min(), df['price'].max()),
            'most_common_categories': pd.Series([cat for cats in df['categories'] for cat in cats]).value_counts().head(10).to_dict()
        }
        
        return stats

    def nutrition_analysis(self):
        """Analiza wartości odżywczych"""
        df = self.get_products_dataframe()
        
        nutrition_stats = {
            'average_calories': df['calories'].mean(),
            'average_protein': df['protein'].mean(),
            'average_fat': df['total_fat'].mean(),
            'average_carbs': df['total_carbs'].mean(),
            'correlation_matrix': df[['calories', 'protein', 'total_fat', 'total_carbs']].corr().to_dict()
        }
        
        return nutrition_stats

    def generate_visualizations(self, output_dir='analysis_results'):
        """Generuje wizualizacje danych"""
        df = self.get_products_dataframe()
        
        # Utworzenie katalogu na wyniki
        Path(output_dir).mkdir(exist_ok=True)
        
        # 1. Rozkład kalorii
        plt.figure(figsize=(10, 6))
        sns.histplot(data=df, x='calories', bins=30)
        plt.title('Distribution of Calories per 100g')
        plt.savefig(f'{output_dir}/calories_distribution.png')
        plt.close()
        
        # 2. Porównanie wartości odżywczych
        nutrition_comparison = df[['calories', 'protein', 'total_fat', 'total_carbs']].mean()
        plt.figure(figsize=(8, 6))
        nutrition_comparison.plot(kind='bar')
        plt.title('Average Nutritional Values per 100g')
        plt.savefig(f'{output_dir}/nutrition_comparison.png')
        plt.close()
        
        # 3. Korelacja między wartościami odżywczymi
        plt.figure(figsize=(10, 8))
        sns.heatmap(df[['calories', 'protein', 'total_fat', 'total_carbs']].corr(), 
                   annot=True, cmap='coolwarm')
        plt.title('Correlation between Nutritional Values')
        plt.savefig(f'{output_dir}/nutrition_correlation.png')
        plt.close()

    def category_analysis(self):
        """Analiza produktów według kategorii"""
        df = self.get_products_dataframe()
        
        category_stats = defaultdict(dict)
        for category in set([c for cats in df['categories'] for c in cats]):
            category_products = df[df['categories'].apply(lambda x: category in x)]
            
            category_stats[category] = {
                'product_count': len(category_products),
                'average_price': category_products['price'].mean(),
                'average_calories': category_products['calories'].mean(),
                'average_protein': category_products['protein'].mean(),
                'price_range': (category_products['price'].min(), 
                              category_products['price'].max())
            }
        
        return dict(category_stats)

    def generate_report(self, output_file='analysis_report.json'):
        """Generuje kompletny raport analizy"""
        report = {
            'basic_statistics': self.basic_statistics(),
            'nutrition_analysis': self.nutrition_analysis(),
            'category_analysis': self.category_analysis()
        }
        
        # Zapisanie raportu do pliku JSON
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=4, ensure_ascii=False)
        
        # Generowanie wizualizacji
        self.generate_visualizations()
        
        return report

    def price_analysis(self):
        """Analiza cen produktów"""
        df = self.get_products_dataframe()
        
        price_stats = {
            'average_price_by_category': df.groupby('categories')['price'].mean().to_dict(),
            'price_distribution': {
                'mean': df['price'].mean(),
                'median': df['price'].median(),
                'std': df['price'].std(),
                'quartiles': df['price'].quantile([0.25, 0.5, 0.75]).to_dict()
            },
            'price_by_manufacturer': df.groupby('manufacturer')['price'].agg(['mean', 'min', 'max']).to_dict()
        }
        
        return price_stats

# Przykład użycia:
if __name__ == '__main__':
    db_manager = DatabaseManager()
    analyzer = ProductAnalyzer(db_manager)
    
    # Generowanie pełnego raportu
    report = analyzer.generate_report()
    
    # Przykładowe wykorzystanie poszczególnych analiz
    basic_stats = analyzer.basic_statistics()
    print("\nPodstawowe statystyki:")
    print(f"Liczba produktów: {basic_stats['total_products']}")
    print(f"Liczba producentów: {basic_stats['unique_manufacturers']}")
    
    nutrition_stats = analyzer.nutrition_analysis()
    print("\nŚrednie wartości odżywcze:")
    print(f"Kalorie: {nutrition_stats['average_calories']:.2f} kcal/100g")
    print(f"Białko: {nutrition_stats['average_protein']:.2f} g/100g")
    
    # Generowanie wizualizacji
    analyzer.generate_visualizations()
```

Ten kod oferuje:

1. Podstawowe analizy statystyczne:
   - Liczba produktów
   - Liczba producentów
   - Rozkład kategorii
   - Statystyki cenowe

2. Analizę wartości odżywczych:
   - Średnie wartości
   - Korelacje między składnikami
   - Rozkłady wartości

3. Analizę kategorii:
   - Statystyki per kategoria
   - Porównania między kategoriami

4. Wizualizacje:
   - Wykresy rozkładów
   - Mapy cieplne korelacji
   - Porównania wartości odżywczych

Możemy rozszerzyć analizę o:
1. Analizę trendów czasowych
2. Porównania między sieciami sklepów
3. Analizę składników i alergenów
4. Rekomendacje produktów
5. Analizę wartości odżywczych względem ceny

Którą z tych dodatkowych funkcji chciałbyś rozwinąć?
